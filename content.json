{"meta":{"title":"暴力阿桑","subtitle":null,"description":"进击的程序猿","author":"阿桑","url":"https://sangyue174.github.io/blog"},"pages":[{"title":"archives","date":"2018-05-31T16:00:47.000Z","updated":"2018-05-31T16:00:47.331Z","comments":true,"path":"archives/index.html","permalink":"https://sangyue174.github.io/blog/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-31T15:54:19.000Z","updated":"2018-06-01T05:19:46.533Z","comments":true,"path":"categories/index.html","permalink":"https://sangyue174.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-31T15:52:28.000Z","updated":"2018-06-01T05:19:51.553Z","comments":true,"path":"tags/index.html","permalink":"https://sangyue174.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-05-31T08:32:11.000Z","updated":"2018-06-01T06:11:40.719Z","comments":true,"path":"about/index.html","permalink":"https://sangyue174.github.io/blog/about/index.html","excerpt":"","text":"我只是一个普通的java小猿，现在在北京，平时喜欢研究一些奇怪好玩的东西。其实很久之前就想建个博客，来记录一下生活，但是总是因为各种原因（还是懒）搁置了，后来想了一下，弄一个博客整理一下知识，给自己做个定位。既然开始了，就不要轻易放弃，不管是做什么，希望各位看官可以坚持自己的方向，勇往直前。 2018年05月31日 16时44分54秒"},{"title":"更新日志","date":"2018-05-31T15:54:19.000Z","updated":"2018-06-01T05:19:32.983Z","comments":true,"path":"board/index.html","permalink":"https://sangyue174.github.io/blog/board/index.html","excerpt":"","text":"更新日志如下2018年6月1日 切换Next主题 配置评论系统，阅读统计 2018年5月30日 初始化项目"}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2018-06-01T06:56:27.000Z","updated":"2018-06-01T08:11:46.619Z","comments":true,"path":"2018/06/01/设计模式/","link":"","permalink":"https://sangyue174.github.io/blog/2018/06/01/设计模式/","excerpt":"","text":"代理模式特点： 1.执行者、被代理人（执行者就是代理人（媒婆），被代理人就是原操作者（相亲人）） 2.对于被代理人来说，这件事情一定是要做的，但是自己有不想做或者没有时间做（不专业），这时候就要找代理。 3.需要获取到被代理人的个人资料（执行者需要持有被代理对象的引用）。 代理模式关心的过程，不是结果。 总结：字节码重组 例子：AOP实现、拦截器、解耦、功能增强、租房中介、火车票黄牛、媒人、明星经纪人、快递 代理分为：静态代理、动态代理 静态代理，在代理之前所有的内容都是已知的（人工），动态代理，在代理之前所有的内容都是未知的（自动化、智能化） 代理分为两个角色，代理角色、被代理的角色（目标对象），两者之间发生一些关系，对于被代理人来说，这件事情一定是要做的，但是自己有不想做或者没有时间做（不专业），这时候就要找代理。 jdk动态代理：是通过接口来进行强制转换的，生产的代理对象可以转换为接口 字节码重组原理： 拿到被代理对象的引用，并且获取到它所有的接口（反射获取） 通过jdk Proxy类重新生成一个新的类，同时新的类实现被代理类实现的所有的接口 动态生成Java代码，把新加的业务逻辑由一定的代码去调用（在代码中实现），用代码生成代码。 编译新生成的Java代码.class 在重新加载到JVM中运行 cglib动态代理：是通过生成一个被代理对象的子类，然后重写父类的方法，来实现。生成以后的代理对象，可以强制转换为被代理对象（也就是自己写的类-父类），核心就是子类引用赋值给父类。让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象，或者需要安全控制的对象。 工厂模式注重结果，隐藏复杂的逻辑处理过程，只关心执行结果。简单工厂模式：所有的产品都是一个工厂生产出来的（大而全的），对于工厂来说不太合理工厂方法模式：对于用户来讲，需要用户知道各自的生产厂商，增加了代码的使用复杂度，这对于用户来讲是不合理的。一个工厂接口，定义了工厂方法，分别由不同的工厂来实现这个接口，用来生产不同的产品。抽象工厂模式：抽象类，定义抽象方法和普通方法，子类工厂集成该抽象工厂，实现抽象方法，完成各自工厂的功能。工厂方法倾向于拥有一个抽象产品，每个工厂对应一个产品，比如薯条/鸡翅工厂；而抽象工厂倾向于拥有多个抽象产品，每个工厂对应一条产品线，比如薯条，鸡翅，鸡块工厂，这家工厂生产薯条，鸡翅，鸡块这三种产品。 类比一下spring中的bean工厂，抽象bean工厂定义了很多生成bean的类型/方式，有的带参数，有的是class，使用抽象工厂来更好的方便子工厂来提供多种多样bean的实现方式。 单例模式应用场景：保证从系统启动到系统停止，全过程只会产生一个实例。当我们在应用中遇到功能性冲突的时候，需要使用单例模式。懒汉式：看上去比较懒，不到火烧眉毛的时候，他不着急实例化，需要用的时候才初始化。优点：没有任何的锁，绝对线程安全，执行效率比较高，用户体验上，比懒汉式好。缺点：类加载的时候就初始化，不管用不用，都占用空间。饿汗式：看书去像个饿殍，不管你用不用，先吃饱了再说，都先实例化。 类加载顺序，先静态，后动态，先属性，后方法，先上后下 内部类懒汉式：内部类只有在外部类调用的时候，才会被加载，内部类一定是在方法调用之前初始化，巧妙的避免了线程安全问题。兼顾了饿汉式的内存浪费，还兼顾了懒汉式sync性能问题，完美屏蔽了这两个缺点，相对来看最好的单例的实现方式。 注册登记式：采用一个线程安全的容器（map）枚举式：属于注册登记式 反序列化时导致单例破坏：序列化就是将内存中的状态转换为字节码的形式，从而转换为一个IO流，写入其他地方（可以可以是磁盘，网络IO），内存中状态永久保存下来了。反序列化：将已经持久化的字节码内容，转为IO流，通过IO流的读取，进而将读取的内容转为JAVA对象，在转换的过程中会重新new对象 实例化=准备阶段+初始化+赋值 类的初始化过程与类的实例化过程的异同？类的初始化是指类加载过程中的初始化阶段对类变量按照程序猿的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后创建对象的过程。在Java中， 创建一个对象常常需要经历如下几个过程：父类的类构造器() -&gt; 子类的类构造器() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数参考如下：http://blog.csdn.net/justloveyou_/article/details/72466416 原型模式原型模式可以实现对象值的赋值，比如数据库查询出来的内容赋值给pojo或者dto，mvc中的model映射。复制，要求属性名相同，属性值相同，属性类型也相同。java中提供了Cloneable接口，重写里边的clone方法，可以实现对象的copy（潜复制），深克隆可以实现属性的全部克隆，子对象是不同的对象，地址不一样，属性值相同，通过序列化的形式可以实现深度克隆。深克隆实现：将对象写入到字节码数组ByteArrayOutputStream中，然后在把该字节码数组读入到ByteArrayInputStream中，最后把该字节码构造成一个新的对象，待克隆的对象（包含子对象）都需要实现序列化接口。原型模式只是提供了一种解决方案，具体实现方式可以有很多种，反射，循环等等，Spring中的原型模式是用的反射来实现的。Apache 的BeanUtils中的对象复制就是用的反射，不过反射的效率一般比较低。 策略模式旅行路线、比较器、固定算法、购物车特点：最终结果是固定的，执行过程和执行逻辑不一样，供用户选择。 模板（模板方法）模式特点：执行流程固定，但是中间有些步骤有细微的差别（运行时才确定）会有一套统一的流程，这个不能变，顺序步骤一定，但是里边每个步骤的具体实现是可以控制的，比如说制作饮料，需要先加原料，加水，加热，搅拌，冷却，装瓶。这整个的流程不能变，但是具体里边的步骤可以自己控制，不限制你加什么样的原料，多少度的水，如何搅拌等等，最终按这套步骤走下来，就可以做成饮料。这就是模板方法模式，对方法进行改造实现。类似的功能有JdbcTemplate，各种template，流水线工作。java中可以通过抽象类+抽象方法来定制化自己实现的步骤，抽象类+抽象方法这个耦合度还是有些高，因为你在使用的时候需要继承这个类，然后重写抽象方法，这样就和父类（抽象类）甚至父类的父类有很强的耦合关系。基于这种情况，可以采用将这个抽象方法单独抽出来作为接口中的方法，取消这个抽象类的声明，在使用的时候再去实现这个接口或者用匿名内部类来实现，达到解耦的效果，Spring中有很多组件就是这么来使用的。NOTE: 策略模式和模板方法模式的比较策略模式只有选择权（由用户自己选择已有的固定算法）模板模式侧重点不是选择，你没得选，你必须这样做，但是你可以参与其中某一部分的内容自定义，可以改变他的结果。 委派模式有点像代理模式，又有点像策略模式相当于是静态代理的一种非常特殊的情况，全权代理人。负责分发，调度，在分配任务之前，又要做一个权衡选择（策略模式）。以Delegate结尾的类名，带有Dispatcher的就是委派客户请求（boss），委派者(leader)，被委派者(target)，委派者要持有被委派者的引用，干活是你的，功劳是我的代理模式注重的是过程，委派模式注重的是结果。策略模式注重的是可扩展（外部扩展），委派模式注重内部的灵活和复用。委派的核心：分发、调度、派遣是静态代理和策略模式的一种特殊组合。在装饰者中不执行自身的内容就是委派。 适配器模式VGA-HDMI、充电头、插口转换老系统运行了很久比较稳定，但是保持其稳定性，不便再去修改原来的code，但是又要为了兼容新的需求和标准（扩展），我们不得不在系统再去做一些文章。（向下兼容）也可以说是在原先的基础上扩展一些功能（增强、类似的功能），但是不要修改原来的逻辑，如果是是service调用servcie，这种跨功能的不叫适配器。一般来说适配器可以用继承或者拿到目标类的引用来做。通常以Adapter结尾的就是适配器一般适配器自己的接口(IAdaptor)和待适配的接口(IOther)是不同的，在于不同内容的转换，比如 123456789101112131415161718// 类适配器class Adapter extends OtherImpl implements IAdaptor&#123; public void adaptorMethod()&#123; System.out.println(\"适配器方法，我要去适配OtherImpl的方法了\"); otherMethod(); &#125;&#125;// or 对象适配器class Adapter implements IAdaptor&#123; private IOther other;// 待适配的接口 public Adapter(IOther other)&#123; this.other = other; &#125; public void adaptorMethod()&#123; System.out.println(\"适配器方法，我要去适配IOther接口的方法了\"); other.otherMethod(); &#125;&#125; 装饰者模式（包装器模式）decorater为了实现某个类在不修改原始类的基础上进行动态的覆盖和增强（方法）该实现依然保持跟原有类（父类）的关系装饰器模式实际上是一种非常特殊的适配器模式，适配器更针对于兼容。 装饰器模式是一种非常特别的适配器模式装饰者和被装饰者都要实现同一个接口，主要目的是为了扩展，依然保留oop关系（Object Oriented Programming 面向对象的程序设计）满足is-a关系注重的是覆盖、扩展 适配器模式可以不保留层级关系（上层的可以废弃@Deprecated）适配者和被适配者没有必然的层级联系，通常采用代理或者继承形式进行包装满足has-a关系注重兼容、转换 总结：1、装饰器模式中，装饰者和被装饰者必须有共同的父类。2、一般情况下，装饰者（摩卡）中有被装饰者（普通咖啡）（或者他们共同的父类）的引用，通过构造函数来实现将引用付给实例变量3、适配器需要实现另一个接口，而装饰器是实现同一个接口,参考适配器例子 可参考如下：http://blog.csdn.net/wangzhenfei444/article/details/51720883 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 基本接口interface IBase&#123; public void baseMethod();&#125;// 普通实现类class DefaultBase implements IBase&#123; public void baseMethod()&#123; System.out.println(\"这是普通实现方法\"); &#125;&#125;// 方式1：没有抽象装饰器，适用于简单装饰器class Decorator implements IBase&#123; IBase base;// 这是装饰器的关键，需要将接口引用存下来 public DecoraterImpl(Ibase base)&#123; this.base = base; &#125; public baseMethod()&#123; // 装饰器可以在这里实现一些自己的内容 System.out.println(\"进入装饰器Decorator自己的方法\"); base.baseMethod();// 调用base自己的方法 &#125;&#125;// 方式2：使用抽象装饰器，适用于扩展性装饰器// 这是抽象装饰器(这一层抽象接口可以没有)abstract class AbstractDecorator implements IBase&#123; public abstract void description();// 这里定义装饰器特殊的方法&#125;// 这是具体装饰器class Decorator extends AbstractDecorator&#123; IBase base; public Decorator(IBase base)&#123; this.base = base; &#125; public void description()&#123; System.out.println(\"装饰器description方法\") &#125; public baseMethod()&#123; // 装饰器可以在这里实现一些自己的内容，如果直接调用base.Method(),就是一种委派 System.out.println(\"进入装饰器Decorator自己的方法\"); base.baseMethod();// 调用base自己的方法 &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://sangyue174.github.io/blog/categories/Java基础/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sangyue174.github.io/blog/tags/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-25T10:03:19.691Z","updated":"2018-05-25T10:03:19.692Z","comments":true,"path":"2018/05/25/hello-world/","link":"","permalink":"https://sangyue174.github.io/blog/2018/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}